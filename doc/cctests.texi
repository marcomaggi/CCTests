\input texinfo.tex
@c %**start of header
@setfilename cctests.info
@settitle CCTests
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCTests

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCTests

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           cctests

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017

@c ------------------------------------------------------------

@set CCEXCEPTIONS_REQUIRED_VERSION      0.6.2

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a framework to organise test suites.  The library targets @posix{} platforms.

The package depends upon the external package CCExceptions at least version
@value{CCEXCEPTIONS_REQUIRED_VERSION}, and relies on @command{pkg-config} to find it installed on
the system.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* cctests: (cctests).           CCTests a C11 library to organise test suites.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Condition object types.
* system::                      System interface.
* drivers::                     Driving test groups.
* assertions::                  Verifying conditions.
* utils::                       Utility definitions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a framework to organise test suites.  The library targets @posix{} platforms.

The package depends upon the external package CCExceptions at least version
@value{CCEXCEPTIONS_REQUIRED_VERSION}, and relies on @command{pkg-config} to find it installed on
the system.

@value{PACKAGE} installs the single header file @file{cctests.h}.  All the function names in the
@api{} are prefixed with @code{cctests_}; all the preprocessor symbol names are prefixed with
@code{CCTESTS_}; all the type names are prefixed with @code{cctests_} and suffixed with @code{_t}.
The header file @file{cctests.h} appropriately includes the header file @file{ccexceptions.h} from
the package CCExceptions.

The library's @api{} uses both @code{inline} functions and preprocessor macros to integrate some
common operations at the call site.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{cctests_init}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{cctests.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCTESTS],[cctests >= 0.1])
@end example

@noindent
which will set the variables @code{CCTESTS_LIBS} and @code{CCTESTS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([cctests],[cctests_version_string],,
  [AC_MSG_FAILURE([test for CCTests library failed])])
AC_CHECK_HEADERS([cctests.h],,
  [AC_MSG_FAILURE([test for CCTests header failed])])
@end example

@c page
@node init
@chapter Library initialisation


@deftypefun void cctests_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} cctests_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int cctests_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cctests_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int cctests_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Condition object types


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
#include <cctests.h>

cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_error_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_cleanup_handlers(L);
@}
@end example

@menu
* conditions base::             Base condition object.
* conditions success::          Signalling test success.
* conditions failure::          Signalling test failure.
* conditions assertion::        Signalling failed assertions.
* conditions regex::            Regular expression errors.

Convenience condition types

* conditions signal::           Convenience signal.
* conditions signal one::       Convenience signal one.
* conditions signal two::       Convenience signal two.
* conditions signal three::     Convenience signal three.
@end menu

@c page
@node conditions base
@section Base condition object


@cindex Base, exceptional condition
@cindex Exceptional conditions, base


The @dfn{base exceptional--condition object--type} is the base for all the condition types defined
by @value{PACKAGE} related to testing operations; @value{PACKAGE} might raise exceptions not derived
from this type, when an internal error occurs.

We are @strong{not} meant to instantiate condition objects of type @emph{base} (so there is no
@code{new} function), but we can derive new types from it (so there is an @code{init} function).

To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_base(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_base_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_base_t
Type of data structure representing the base exceptional--condition descriptor.  It has the
following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the root descriptor; @xref{conditions root, CCExceptions,
CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_base_t
Type of data structure representing the base exceptional--condition object.  It has the following
public fields:

@table @code
@item cce_condition_root_t root
The parent condition type.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_base_t const * const} cctests_descriptor_base_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_base (cctests_condition_base_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_base_t}.
@end deftypefun


@deftypefun bool cctests_condition_is_base (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_base_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_base_t} we can copy the code in the files:

@example
condition-base-subtype.c
condition-base-subtype-headear.h
condition-base-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_base_subtype_t}.

@c page
@node conditions success
@section Signalling test success


@cindex Test success, exceptional condition
@cindex Exceptional conditions, test success


The @dfn{success exceptional--condition object--type} can be used to signal success in a test
execution; it is not the only way a test can succeed, it is just an option that can be useful in
some special cases.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_success(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_success_t, C, cce_condition(L));
    do_something_with(C);
    cce_run_cleanup_handlers_final(L);
  @} else @{
    cce_run_error_handlers_final(L);
  @}
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_success_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_success_t
Type of data structure representing the condition object.  It has the following public fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_success_t const * const} cctests_descriptor_success_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_success (cctests_condition_success_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_success_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_success (void)
Return a pointer to exceptional--condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_success (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_success_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_success_t} we can copy the code in the files:

@example
condition-success-subtype.c
condition-success-subtype-headear.h
condition-success-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_success_subtype_t}.

@c page
@node conditions failure
@section Signalling test failure


@cindex Test failure, exceptional condition
@cindex Exceptional conditions, test failure


The @dfn{failure exceptional--condition object--type} is used by @value{PACKAGE} to signal failure
in a test execution; this is the base for all the types that signal a test failure.  We can
instantiate this type and also derive new types from it.  To catch this exceptional condition we can
do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_failure(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_failure_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_failure_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_failure_t
Type of data structure representing the condition object.  It has the following public fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_failure_t const * const} cctests_descriptor_failure_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_failure (cctests_condition_failure_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_failure_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_failure (void)
Return a pointer to exceptional--condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_failure (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_failure_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_failure_t} we can copy the code in the files:

@example
condition-failure-subtype.c
condition-failure-subtype-headear.h
condition-failure-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_failure_subtype_t}.

@c page
@node conditions assertion
@section Signalling failed assertions


@cindex Failed assertion, exceptional condition
@cindex Exceptional conditions, failed assertion


The @dfn{assertion exceptional--condition object--type} is used by @value{PACKAGE} to signal failure
in an assertion verification, for example by @cfunc{cctests_assertion}.  We can instantiate this
type and also derive new types from it.  To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_assertion(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_assertion_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_assertion_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_failure_ptr},
@ref{conditions failure, Signalling test failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_assertion_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_failure_t failure
The condition object's base values.

@item char const * expr
Pointer to a statically allocated @asciiz{} string representing the failed assertion's expression.

@item char const * filename
Pointer to a statically allocated @asciiz{} string representing the pathname of the source file in
which the failed assertion is located.  This value is meant to be generated with the preprocessor
macro @code{__FILE__}.

@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function in which
the failed assertion is located.  This value is meant to be generated with the preprocessor macro
@code{__func__}.

@item int linenum
The line number in the source file in which the failed assertion is located.  This value is meant to
be generated with the preprocessor macro @code{__LINE__}.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_assertion_t const * const} cctests_descriptor_assertion_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_assertion (cctests_condition_assertion_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_assertion_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_assertion (cce_destination_t @var{L}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_assertion (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_assertion_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_assertion_t} we can copy the code in the files:

@example
condition-assertion-subtype.c
condition-assertion-subtype-headear.h
condition-assertion-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_assertion_subtype_t}.

@c page
@node conditions regex
@section Regular expression errors


@value{PACKAGE} uses @posix{} regular expressions to allow the user to select which tests and test
groups to run.

@menu
* conditions regex error::      Base regular expression errors.
* conditions regex comp::       Regular expression compilation errors.
@end menu

@c page
@node conditions regex error
@subsection Base regular expression errors


@cindex Base regular expression error, exceptional condition
@cindex Regular expression error, base exceptional condition
@cindex Exceptional conditions, base regular expression error


The @dfn{regex error exceptional--condition object--type} is used by @value{PACKAGE} to represent an
error related to the use of @posix{} regular expressions; this type is the base for more specialised
types.  We can instantiate this type and also derive new types from it.  To catch this exceptional
condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_regex_error(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_regex_error_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_regex_error_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_runtime_error_ptr},
@xref{conditions run-time error, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_regex_error_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
The condition object's base values.

@item int errcode
The error code as defined by the @posix{} regex @api{}.

@item char error_message[1024]
An array holding the @asciiz{} representation of the error description generated by
@cfunc{regerror}.  If the message is longer than @math{1024} characters: it is truncated.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_regex_error_t const * const} cctests_descriptor_regex_error_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_regex_error (cctests_condition_regex_error_t * @var{C}, int @var{errcode})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_regex_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_regex_error (cce_destination_t @var{L}, int @var{errcode})
Return a pointer to exceptional condition object.  If an error occurs building the condition object:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_regex_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_descriptor_regex_error_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_regex_error_t} we can copy the code in the
files:

@example
condition-regex-error-subtype.c
condition-regex-error-subtype-headear.h
condition-regex-error-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_regex_error_subtype_t}.

@c page
@node conditions regex comp
@subsection Regular expression compilation errors


@cindex Regular expression compilation error, exceptional condition
@cindex Exceptional conditions, regular expression compilation error


The @dfn{regex compilation error exceptional--condition object--type} is used by @value{PACKAGE} to
represent an error compiling a @posix{} regular expressions; it is used when calling the standard
function @cfunc{regcomp}.  We can instantiate this type and also derive new types from it.  To catch
this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_regex_compilation_error(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_regex_compilation_error_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_regex_compilation_error_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_regex_error_ptr}, @ref{conditions regex error, Base regular expression
errors}.
@end deftp


@deftp {Struct Typedef} cctests_condition_regex_compilation_error_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_regex_error_t regex_error
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_regex_compilation_error_t const * const} cctests_descriptor_regex_compilation_error_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_regex_compilation_error (cctests_condition_regex_compilation_error_t * @var{C}, int @var{errcode})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_regex_compilation_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_regex_compilation_error (cce_destination_t @var{L}, int @var{errcode})
Return a pointer to exceptional condition object.  If an error occurs building the condition object:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_regex_compilation_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_descriptor_regex_compilation_error_t};
otherwise return @cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_regex_compilation_error_t} we can copy the code
in the files:

@example
condition-regex-compilation-error-subtype.c
condition-regex-compilation-error-subtype-headear.h
condition-regex-compilation-error-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_regex_compilation_error_subtype_t}.

@c page
@node conditions signal
@section Convenience signal


@cindex Signal, exceptional condition
@cindex Exceptional conditions, signal


We can use the @dfn{signal exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

If we raise an exception of this type, or one of its sub--types, then we must also catch it before
it reaches @value{PACKAGE}'s functions; otherwise the currently executed test will be considered
failed in an abnormal way.


@deftp {Struct Typedef} cctests_descriptor_signal_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_t const * const} cctests_descriptor_signal_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_new_signal (cctests_condition_signal_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_t} we can copy the code in the files:

@example
condition-signal-subtype.c
condition-signal-subtype-headear.h
condition-signal-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_subtype_t}.

@c page
@node conditions signal one
@section Convenience signal one


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


We can use the @dfn{signal--1 exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_1(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_1_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_signal_1_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_signal_ptr},
@ref{conditions signal, Convenience signal}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_1_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_signal_t signal
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_1_t const * const} cctests_descriptor_signal_1_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_new_signal_1 (cctests_condition_signal_1_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_1_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_1 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_1 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_1_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_1_t} we can copy the code in the files:

@example
condition-signal-1-subtype.c
condition-signal-1-subtype-headear.h
condition-signal-1-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_1_subtype_t}.

@c page
@node conditions signal two
@section Convenience signal two


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


We can use the @dfn{signal--2 exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[2];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_2(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_2_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_signal_2_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_signal_ptr},
@ref{conditions signal, Convenience signal}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_2_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_signal_t signal
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_2_t const * const} cctests_descriptor_signal_2_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_new_signal_2 (cctests_condition_signal_2_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_2_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_2 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_2 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_2_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_2_t} we can copy the code in the files:

@example
condition-signal-2-subtype.c
condition-signal-2-subtype-headear.h
condition-signal-2-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_2_subtype_t}.

@c page
@node conditions signal three
@section Convenience signal three


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


We can use the @dfn{signal--3 exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[3];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_3(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_3_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_signal_3_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_signal_ptr},
@ref{conditions signal, Convenience signal}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_3_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_signal_t signal
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_3_t const * const} cctests_descriptor_signal_3_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_new_signal_3 (cctests_condition_signal_3_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_3_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_3 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_3 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_3_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_3_t} we can copy the code in the files:

@example
condition-signal-3-subtype.c
condition-signal-3-subtype-headear.h
condition-signal-3-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_3_subtype_t}.

@c page
@node system
@chapter System interface


@value{PACKAGE} provides interfaces to some system primitives to facilitate writing tests without
using external libraries; the interfaces are wrappers for some basic @posix{} system calls.  Each
wrapper accepts a pointer to @objtype{cce_location_t} as argument and, in case of error, it will
perform a non--local exit by jumping to the selected location.

The wrapper functions accept the same arguments of the system calls and return the same return value
of the system calls (if they complete successfully).

All the wrappers reset @code{errno} to zero before performing the system call and reset it to zero
before returning.  In case of error: the raised exceptional condition objects are of type
@objtype{cce_condition_errno_t}.

@menu
* system memory::               Memory allocation interface.
@end menu

@c page
@node system memory
@section Memory allocation interface


@deftypefun {void *} cctests_sys_malloc (cce_destination_t  @var{L}, size_t @var{size})
Wrapper for @cfunc{malloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cctests_sys_realloc (cce_destination_t  @var{L}, void * @var{ptr}, size_t @var{newsize})
Wrapper for @cfunc{realloc}.  This function never returns @cnull{}.
@end deftypefun


@deftypefun {void *} cctests_sys_calloc (cce_destination_t  @var{L}, size_t @var{count}, size_t @var{eltsize})
Wrapper for @cfunc{calloc}.  This function never returns @cnull{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Handler for allocated memory

We can handle memory that must be released with the standard function @cfunc{free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers(L);
  cce_condition_delete(cce_condition(L));
@} else @{
  void *  P = cctests_sys_malloc(L, 4096);
  cce_cleanup_handler_malloc_init(L, H, P);
  cce_run_cleanup_handlers(L);
@}
@end example


@deftypefun void cctests_cleanup_handler_malloc_init (cce_destination_t  @var{L}, cce_handler_t * @var{H}, void * @var{P})
@deftypefunx void cctests_error_handler_malloc_init (cce_destination_t  @var{L}, cce_handler_t * @var{H}, void * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory block referenced by @var{P} using the standard function @cfunc{free}.
@end deftypefun

@c page
@node drivers
@chapter Driving test groups


We create and run test group as follows, in a full program:

@example
#include <cctests.h>
#include <stdlib.h>
#include <stdbool.h>

/* test functions */
void test_this (cce_destination_t L);
void test_that (cce_destination_t L);

int
main (void)
@{
  cctests_begin_group("spiffy tests");
  @{
    cctests_run(test_this);
    cctests_run(test_that);
  @}
  cctests_end_group();

  if (cctests_latest_group_completed_successfully()) @{
    exit(EXIT_SUCCESS);
  @} else @{
    exit(EXIT_FAILURE);
  @}
@}

void
test_this (cce_destination_t L CCTESTS_UNUSED)
@{
  cctests_assert(true);
@}

void
test_that (cce_destination_t L CCTESTS_UNUSED)
@{
  cctests_assert(true);
@}
@end example


@deftypefun void cctests_begin_group (char const * const @var{test_group_name})
Begin a group of tests; initialise the internal state.  The argument is an @asciiz{} string
representing the name of this group.  Print a message on @code{stderr}.
@end deftypefun


@deftypefun void cctests_end_group (void)
End the latest group of tests begun with @cfunc{cctests_end_group}; finalise the internal state.
Print a message on @code{stderr} reporting the result.
@end deftypefun


@deftypefn {Preprocessor Macro} void cctests_run (cctests_fun_t * @var{fun})
Run the test function @var{fun} in the context of the currently active test group.  Print reports on
@code{stderr}.
@end deftypefn


@deftypefun bool cctests_latest_group_completed_successfully (void)
Return @ctrue{} if the latest test group has completed successfully; otherwise return @cfalse{}.
@end deftypefun


@deftypefn {Function Typedef} void cctests_fun_t (cce_destination_t @var{L})
Prototype of test functions run by @cfunc{cctests_run}.  When successful: the test function should
just return to its caller.  If an error occurs: the test function should raise an exception by
performing a non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions
@chapter Verifying conditions


@deftypefn {Preprocessor Macro} void cctests_assert (@var{expr})
Evaluate the expression @var{expr}; this macro is similar, but not equal, to the standard
@cfunc{assert}.  If the expression evaluates to @ctrue{}: just return.  Otherwise raise an exception
by performing a non--local exit to a location internally selected by @value{PACKAGE}.

Here are some usage examples:

@example
cctests_assert(true);   /* success */
cctests_assert(false);  /* failure */

@{
  void *  P = malloc(16);

  cctests_assert(NULL != P);
@}

@{
  char const *  A = "ciao";
  char const *  B = "hello";

  cctests_assert(0 == strcmp(A, B));
@}
@end example
@end deftypefn

@c page
@node utils
@chapter Utility definitions


@defmac CCTESTS_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCTESTS_PC(cctests_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
cctests_descriptor_test_failure_t * C = \
   (cctests_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCTESTS_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

we can find the package CCExceptions at:

@center @url{http://github.com/marcomaggi/ccexceptions/}


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

