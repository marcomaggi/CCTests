\input texinfo.tex
@c %**start of header
@setfilename cctests.info
@settitle CCTests
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCTests

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCTests

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           cctests

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017

@c ------------------------------------------------------------

@set CCEXCEPTIONS_REQUIRED_VERSION      0.6.1

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a framework to organise test suites.  The library targets @posix{} platforms.

The package depends upon the external package CCExceptions at least version
@value{CCEXCEPTIONS_REQUIRED_VERSION}, and relies on @command{pkg-config} to find it installed on
the system.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* cctests: (cctests).           CCTests a C11 library to organise test suites.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Condition object types.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a framework to organise test suites.  The library targets @posix{} platforms.

The package depends upon the external package CCExceptions at least version
@value{CCEXCEPTIONS_REQUIRED_VERSION}, and relies on @command{pkg-config} to find it installed on
the system.

@value{PACKAGE} installs the single header file @file{cctests.h}.  All the function names in the
@api{} are prefixed with @code{cctests_}; all the preprocessor symbol names are prefixed with
@code{CCTESTS_}; all the type names are prefixed with @code{cctests_} and suffixed with @code{_t}.

The library's @api{} uses both @code{inline} functions and preprocessor macros to integrate some
common operations at the call site.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{cctests_init}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{cctest.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCTESTS],[cctests >= 0.1])
@end example

@noindent
which will set the variables @code{CCTESTS_LIBS} and @code{CCTESTS_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([cctests],[cctests_version_string],,
  [AC_MSG_FAILURE([test for Cctests library failed])])
AC_CHECK_HEADERS([cctests.h],,
  [AC_MSG_FAILURE([test for Cctests header failed])])
@end example

@c page
@node init
@chapter Library initialisation


@deftypefun void cctests_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} cctests_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int cctests_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cctests_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int cctests_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Condition object types


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
#include <ccpair.h>

cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_error_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_cleanup_handlers(L);
@}
@end example

@menu
* conditions base::             Base condition object.

Convenience condition types

* conditions signal one::       Convenience signal one.
* conditions signal two::       Convenience signal two.
* conditions signal three::     Convenience signal three.
@end menu

@c page
@node conditions base
@section Base condition object


@cindex base, exceptional condition
@cindex Exceptional conditions, base


@deftp {Struct Typedef} cctests_descriptor_base_t
Type of data structure representing the base exceptional--condition descriptor for the exceptions
defined by @value{PACKAGE}.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the root descriptor.  @xref{conditions root, CCExceptions,
CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_base_t
Type of data structure representing the base exceptional--condition object for the exceptions
defined by @value{PACKAGE}.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_base_t const * const} cctests_descriptor_base
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun bool cctests_condition_is_base (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{cctests_descriptor_base}; otherwise return @cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_base(cce_condition(L))) @{
    cctests_condition_base_t * C = (cctests_condition_base_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions signal one
@section Convenience signal one


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


@deftp {Struct Typedef} cctests_descriptor_signal_1_t
Type of data structure representing the exceptional--condition descriptor for the condition
@emph{signal one}: an exception that client code can use to signal some test result.  It has the
following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_1_t
Type of data structure representing the exceptional--condition object for the condition @emph{signal
one}: an exception that client code can use to signal some test result.  It has the following public
fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_1_t const * const} cctests_descriptor_signal_1
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_1 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_1 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{cctests_descriptor_signal_1}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_1(cce_condition(L))) @{
    cctests_condition_signal_1_t * C = (cctests_condition_signal_1_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions signal two
@section Convenience signal two


@cindex Signal two, exceptional condition
@cindex Exceptional conditions, signal two


@deftp {Struct Typedef} cctests_descriptor_signal_2_t
Type of data structure representing the exceptional--condition descriptor for the condition
@emph{signal two}: an exception that client code can use to signal some test result.  It has the
following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_2_t
Type of data structure representing the exceptional--condition object for the condition @emph{signal
two}: an exception that client code can use to signal some test result.  It has the following public
fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_2_t const * const} cctests_descriptor_signal_2
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_2 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_2 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{cctests_descriptor_signal_2}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_2(cce_condition(L))) @{
    cctests_condition_signal_2_t * C = (cctests_condition_signal_2_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@node conditions signal three
@section Convenience signal three


@cindex Signal three, exceptional condition
@cindex Exceptional conditions, signal three


@deftp {Struct Typedef} cctests_descriptor_signal_3_t
Type of data structure representing the exceptional--condition descriptor for the condition
@emph{signal three}: an exception that client code can use to signal some test result.  It has the
following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_3_t
Type of data structure representing the exceptional--condition object for the condition @emph{signal
three}: an exception that client code can use to signal some test result.  It has the following
public fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_3_t const * const} cctests_descriptor_signal_3
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_3 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_3 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{cctests_descriptor_signal_3}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_3(cce_condition(L))) @{
    cctests_condition_signal_3_t * C = (cctests_condition_signal_3_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end smallexample

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

we can find the package CCExceptions at:

@center @url{http://github.com/marcomaggi/ccexceptions/}


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

