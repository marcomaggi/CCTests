\input texinfo.tex
@c %**start of header
@setfilename cctests.info
@settitle CCTests
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCTests

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCTests

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           cctests

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018, 2019

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCTESTS
@set PackagePkgconfigModule             cctests
@set PackageLibsVar                     @env{CCTESTS_LIBS}
@set PackageCflagsVar                   @env{CCTESTS_CFLAGS}
@c This is the stem of the library in "libcctests.so".
@set PackageLibstem                     cctests
@set PackageApiPrefixLower              cctests_
@set PackageApiPrefixUpper              CCTESTS_

@set PackageHeader                      cctests.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@c ------------------------------------------------------------------------

@set CCEXCEPTIONS_REQUIRED_VERSION      0.8.0

@c ------------------------------------------------------------

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a framework to organise test suites.  The library targets @posix{} platforms.

This package depends upon the external packages: CCExceptions at least version
@value{CCEXCEPTIONS_REQUIRED_VERSION}; This package relies on @command{pkg-config} to find the
dependency packages installed on the system.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* cctests: (cctests).           CCTests a C11 library to organise test suites.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* init::                        Library initialisation.
* groups::                      Test groups.
* funcs::                       Test functions.
* assertions::                  Verifying assertions.
* process::                     Running processes.
* conditions::                  Condition object types.
* utils::                       Utility definitions.
* constants::                   Useful constants.
* debugging::                   Debugging facilities.
* automake::                    Interfacing with @gnu{} Automake.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a framework to organise test suites.  The library targets @posix{} platforms.

This package depends upon the external packages: CCExceptions at least version
@value{CCEXCEPTIONS_REQUIRED_VERSION}; This package relies on @command{pkg-config} to find the
dependency packages installed on the system.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the function names
in the @api{} are prefixed with @code{@value{PackageApiPrefixLower}}; all the preprocessor symbol
names are prefixed with @code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.  The header file
@value{PackageHeaderFile} appropriately includes the header file @file{ccexceptions.h} from the
package CCExceptions.

The library's @api{} uses both @code{inline} functions and preprocessor macros to integrate some
common operations at the call site.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{cctests_init}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @value{PackageHeaderFile} as first header, or we
include the following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@include overview-linking.texi
@include overview-ccexceptions.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} cctests_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int cctests_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int cctests_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int cctests_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node init
@chapter Library initialisation


A test suite under the management of @value{PACKAGE} is a collection of test programs.  Each test
program should have the following structure:

@example
#include <cctests.h>

cctests_fun_t   test_1_1;
cctests_fun_t   test_1_2;
cctests_fun_t   test_2_1;
cctests_fun_t   test_2_2;

int
main (void)
@{
  cctests_init("demo");
  @{
    cctests_begin_group("one");
    @{
      cctests_run(test_1_1);
      cctests_run(test_1_2);
    @}
    cctests_end_group();

    cctests_begin_group("two");
    @{
      cctests_run(test_2_1);
      cctests_run(test_2_2);
    @}
    cctests_end_group();
  @}
  cctests_final();
@}

void test_1_1 (cce_destination_t L) @{ ... @}
void test_1_2 (cce_destination_t L) @{ ... @}
void test_2_1 (cce_destination_t L) @{ ... @}
void test_2_2 (cce_destination_t L) @{ ... @}
@end example

@noindent
notice that first of all we must call the initialisation function @cfunc{cctests_init}.  We are free
to put the test groups in subordinate functions.


@deftypefun void cctests_init (char const * @var{test_file_name})
Initialise the internal structures of the library; this function must be called before doing
everything else in a test program.  It is fine to call this function multiple times.

The argument @var{test_file_name} must reference an @asciiz{} string representing the name of the
test program.

@quotation
@strong{NOTE} We could generate the value of the argument @var{test_file_name} with the preprocessor
macro @code{__FILE__}, but we must be ware that such value includes directory and file extension
parts we may not want (because they make it more complex to compose a regular expression that
matches).
@end quotation

The test file name is used as follows:

@itemize
@item
@cindex @env{cctests_file}, environment variable
@cindex Environment variable @env{cctests_file}
If the string matches the @posix{} regular expression in the environment variable
@env{cctests_file}: this function initialises the library and returns.  This way the test program is
executed.  If @env{cctests_file} is unset or set to the empty string: the test program name matches
and the tests are executed.

@item
Otherwise this function terminates the current process by calling:

@example
exit(77);
@end example

@noindent
effectively skipping this test program.  The exit status @code{77} is recognised by @gnu{}
Automake's test harness as the code signalling a skipped test.
@end itemize
@end deftypefun


@deftypefun void cctests_final (void)
Finalise a test program.  This function calls @cfunc{exit} to terminate the current process.  The
main purpose of this function is to select the correct exit status to interface, for example, to
@gnu{} Automake's test harness.
@end deftypefun


@deftypefun void ctests_reset_global_state (void)
Reset the internal state to represent an all--successful execution so far.  We can use this function
if we want @cfunc{cctests_final} to exit successfully the current process.
@end deftypefun


@deftypevar {FILE *} cctests_log_stream
An output stream used to log messages.  It is initialised to @code{stderr}.
@end deftypevar

@c page
@node groups
@chapter Test groups


A test group is a set of tests that we consider related, or example: all the tests of a single C
function applied to a single category of operands.  We create and run test group as follows:

@example
cctests_begin_group("spiffy tests");
@{
  cctests_run(test_this);
  cctests_run(test_that);
@}
cctests_end_group();
@end example

@value{PACKAGE}'s @api{} allows us to select which groups to run in a test program using the
environment variable @env{cctests_group}.


@deftypefun void cctests_begin_group (char const * @var{test_group_name})
Begin a group of tests; initialise the internal state.  The argument is an @asciiz{} string
representing the name of this group.  Print a message on the log stream to report the operation.

The test group name is used as follows:

@itemize
@item
@cindex @env{cctests_group}, environment variable
@cindex Environment variable @env{cctests_group}
If the string matches the @posix{} regular expression in the environment variable
@env{cctests_group}: this function initialises the group and returns.  This way the test group is
executed.  If @env{cctests_group} is unset or set to the empty string: the test group name matches
and the tests are executed.

@item
Otherwise this function configures the internal state of the library to skip the tests until the
next call to @cfunc{cctests_end_group}.
@end itemize
@end deftypefun


@deftypefun void cctests_end_group (void)
End the latest group of tests begun with @cfunc{cctests_begin_group}; finalise the internal state.
Print a message on the log stream to report the operation.
@end deftypefun


@deftypefun bool cctests_latest_group_completed_successfully (void)
Return @ctrue{} if the latest test group has completed successfully; otherwise return @cfalse{}.
@end deftypefun

@c page
@node funcs
@chapter Test functions


Test functions are where the meat of the tests is placed.  We can define a test function as:

@example
void
test_1_1 (cce_destination_t L)
@{
  ...
@}
@end example


@deftypefn {Preprocessor Macro} void cctests_run (cctests_fun_t * @var{fun})
@cindex @env{cctests_name}, environment variable
@cindex Environment variable @env{cctests_name}
Run the test function @var{fun} in the context of the currently active test group.  Print reports on
log stream.  The string name of @var{fun} is used as follows:

@itemize
@item
@cindex @env{cctests_name}, environment variable
@cindex Environment variable @env{cctests_name}
If the string matches the @posix{} regular expression in the environment variable
@env{cctests_name}: this function executes the test.  If @env{cctests_name} is unset or set to the
empty string: the test function name matches and the test is executed.

@item
Otherwise this function skips running the test and returns.
@end itemize
@end deftypefn


@deftypefn {Function Typedef} void cctests_fun_t (cce_destination_t @var{L})
Prototype of test functions run by @cfunc{cctests_run}.  When the test completes successfully:

@itemize
@item
The test function might just return to its caller.

@item
The test function might raise an exceptional condition of type @objtype{cctests_condition_success_t}
by performing a non--local exit to @var{L}.
@end itemize

If an error occurs: the test function must raise an exception of type
@objtype{cctests_condition_failure_t} by performing a non--local exit to @var{L}.

If the test function raises an exceptional condition of a type different from
@objtype{cctests_condition_success_t} and @objtype{cctests_condition_failure_t}: the function is
considered failed with a hard error.
@end deftypefn


@deftypefun bool cctests_latest_func_completed_successfully (void)
Return @ctrue{} if the latest test function has completed successfully; otherwise return @cfalse{}.
@end deftypefun


@deftypefun void cctests_skip (void)
Raise an exception of type @objtype{cctests_condition_skipped_t} to signal that this test function
skips its test.  This is useful, for example, if a test function is written for a testee function
that may not exist on the underlying platform; so we can write a test like this:

@example
void
test_1_1 (cce_destination_t upper_L)
@{
#ifdef HAVE_TESTEE_FUNCTION
  ...
#else
  cctests_skip();
#endif
@}
@end example
@end deftypefun

@c page
@node assertions
@chapter Verifying assertions


@menu
* assertions generic::          Generic assertions.
* assertions strings::          Expecting strings.
* assertions equality::         Expecting immediate values.
@end menu

@c page
@node assertions generic
@section Generic assertions


@deftypefn {Preprocessor Macro} void cctests_assert (cce_destination_t @var{L}, @var{expr})
Evaluate the expression @var{expr}; this macro is similar, but not equal, to the standard
@cfunc{assert}.  If the expression evaluates to @ctrue{}: just return.  Otherwise raise an exception
of type @objtype{cctests_condition_assertion_t} by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Preprocessor Macro} void cctests_assert_msg (cce_destination_t @var{L}, @var{expr}, char const * @var{message}, @dots{})
Like @cfunc{cctests_assert}, but format @var{template} with the given optional arguments and include
it in the raised exceptional--condition object as description message.
@end deftypefn


Here are some usage examples:

@example
void
test_1_1 (cce_destination_t L)
@{
  cctests_assert(L, true);   /* success */
@}

void
test_1_2 (cce_destination_t L)
@{
  cctests_assert(L, false);  /* failure */
@}

void
test_1_3 (cce_destination_t L)
@{
  void *  P = malloc(16);

  cctests_assert(L, NULL != P);
@}

void
test_1_4 (cce_destination_t L)
@{
  char const *  A = "ciao";
  char const *  B = "hello";

  cctests_assert(L, 0 == strcmp(A, B));
@}

void
test_1_5 (cce_destination_t upper_L)
@{
  cce_location_t       L[1];
  cce_clean_handler_t  P_H[1];

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    void *      P = cce_sys_malloc_guarded(L, P_H, 1024);

    /* do something with P, then: */
    cctests_assert(L, some_predicate(P));

    cce_run_body_handlers(L);
  @}
@}
@end example

@c page
@node assertions strings
@section Expecting strings


@deftypefn {Preprocessor Macro} void cctests_assert_asciiz (cce_destination_t @var{L}, char const * @var{expected}, char const * @var{result})
Assert that the @asciiz{} string @var{expected} equals the @asciiz{} string @var{result}; the
comparison is performed with the standard function @cfunc{strcmp}.  If the strings are equal: just
return.  Otherwise raise an exception of type
@objtype{cctests_condition_assertion_expected_asciiz_t} by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Preprocessor Macro} void cctests_assert_ascii (cce_destination_t @var{L}, char const * @var{expected}, char const * @var{result}, size_t @var{result_len})
Assert that the first @var{result_len} octets in the @ascii{} string @var{expected} equal the first
@var{result_len} octets in the @ascii{} string @var{result}; the comparison is performed with the
standard function @cfunc{strncmp}.  If the strings are equal: just return.  Otherwise raise an
exception of type @objtype{cctests_condition_assertion_expected_ascii_t} by performing a non--local
exit to @var{L}.
@end deftypefn


Here some usage examples:

@example
void
test_1_1 (cce_destination_t L)
@{
  cctests_assert_asciiz(L, "hello", "ciao");
@}
@end example

@c page
@node assertions equality
@section Expecting immediate values


@menu
* assertions equality chars::   Expecting characters.
* assertions equality shorts::  Expecting short integers.
* assertions equality ints::    Expecting integers.
* assertions equality longs::   Expecting long integers.
* assertions equality llongs::  Expecting long long integers.
* assertions equality int8::    Expecting 8-bit integers.
* assertions equality int16::   Expecting 16-bit integers.
* assertions equality int32::   Expecting 32-bit integers.
* assertions equality int64::   Expecting 64-bit integers.
* assertions equality float::   Expecting single-precision floating-point numbers
* assertions equality double::  Expecting double-precision floating-point numbers
* assertions equality ssize::   Expecting signed integer size.
* assertions equality usize::   Expecting unsigned integer size.
* assertions equality pointer:: Expecting pointers.
* assertions equality ptrdiff:: Expecting pointer difference.
* assertions equality intptr::  Expecting pointer signed integer.
* assertions equality uintptr:: Expecting pointer unsigned integer.
@end menu

@c ------------------------------------------------------------------------

@macro AssertionEqualitySignedFun {TYPENAME, TYPE}
@deftypefn {Preprocessor Macro} void cctests_assert_equal_\TYPENAME\ (cce_destination_t @var{L}, signed \TYPE\ @var{expected}, signed \TYPE\ @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_\TYPENAME\_t} by performing
a non--local exit to @var{L}.
@end deftypefn
@end macro

@macro AssertionEqualityUnsignedFun {TYPENAME, TYPE}
@deftypefn {Preprocessor Macro} void cctests_assert_equal_u\TYPENAME\ (cce_destination_t @var{L}, unsigned \TYPE\ @var{expected}, unsigned \TYPE\ @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_u\TYPENAME\_t} by
performing a non--local exit to @var{L}.
@end deftypefn
@end macro


@macro AssertionEqualityFunctions {TYPENAME, TYPE}
@AssertionEqualitySignedFun{\TYPENAME\, \TYPE\}


@AssertionEqualityUnsignedFun{\TYPENAME\, \TYPE\}
@end macro

@c ------------------------------------------------------------------------

@macro AssertionEqualitySignedBitIntFun {TYPENAME, TYPE}
@deftypefn {Preprocessor Macro} void cctests_assert_equal_\TYPENAME\ (cce_destination_t @var{L}, \TYPE\ @var{expected}, \TYPE\ @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_\TYPENAME\_t} by performing
a non--local exit to @var{L}.
@end deftypefn
@end macro

@macro AssertionEqualityUnsignedBitIntFun {TYPENAME, TYPE}
@deftypefn {Preprocessor Macro} void cctests_assert_equal_u\TYPENAME\ (cce_destination_t @var{L}, u\TYPE\ @var{expected}, u\TYPE\ @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_u\TYPENAME\_t} by
performing a non--local exit to @var{L}.
@end deftypefn
@end macro


@macro AssertionEqualityBitIntFunctions {TYPENAME, TYPE}
@AssertionEqualitySignedBitIntFun{\TYPENAME\, \TYPE\}


@AssertionEqualityUnsignedBitIntFun{\TYPENAME\, \TYPE\}
@end macro

@c page
@node assertions equality chars
@subsection Expecting characters


@AssertionEqualityFunctions{char, char}

@c page
@node assertions equality shorts
@subsection Expecting short integers


@AssertionEqualityFunctions{short, short int}

@c page
@node assertions equality ints
@subsection Expecting integers


@AssertionEqualityFunctions{int, int}

@c page
@node assertions equality longs
@subsection Expecting long integers


@AssertionEqualityFunctions{long, long}

@c page
@node assertions equality llongs
@subsection Expecting long long integers


@AssertionEqualityFunctions{llong, long long}

@c page
@node assertions equality int8
@subsection Expecting 8-bit integers


@AssertionEqualityBitIntFunctions{int8, int8_t}

@c page
@node assertions equality int16
@subsection Expecting 16-bit integers


@AssertionEqualityBitIntFunctions{int16, int16_t}

@c page
@node assertions equality int32
@subsection Expecting 32-bit integers


@AssertionEqualityBitIntFunctions{int32, int32_t}

@c page
@node assertions equality int64
@subsection Expecting 64-bit integers


@AssertionEqualityBitIntFunctions{int64, int64_t}

@c page
@node assertions equality float
@subsection Expecting single-precision floating-point numbers


@deftypefn {Preprocessor Macro} void cctests_assert_equal_float (cce_destination_t @var{L}, float @var{expected}, float @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_float_t} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality double
@subsection Expecting double-precision floating-point numbers


@deftypefn {Preprocessor Macro} void cctests_assert_equal_double (cce_destination_t @var{L}, double @var{expected}, double @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_double_t} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality ssize
@subsection Expecting signed integer size


@deftypefn {Preprocessor Macro} void cctests_assert_equal_ssize (cce_destination_t @var{L}, ssize_t @var{expected}, ssize_t @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_ssize} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality usize
@subsection Expecting unsigned integer size


@deftypefn {Preprocessor Macro} void cctests_assert_equal_size (cce_destination_t @var{L}, size_t @var{expected}, size_t @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_size} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality pointer
@subsection Expecting pointers


@deftypefn {Preprocessor Macro} void cctests_assert_equal_pointer (cce_destination_t @var{L}, void * @var{expected}, void * @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_pointer_t} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality ptrdiff
@subsection Expecting pointer difference


@deftypefn {Preprocessor Macro} void cctests_assert_equal_ptrdiff (cce_destination_t @var{L}, ptrdiff_t @var{expected}, ptrdiff_t @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_ptrdiff} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality intptr
@subsection Expecting pointer signed integer


@deftypefn {Preprocessor Macro} void cctests_assert_equal_intptr (cce_destination_t @var{L}, intptr_t @var{expected}, intptr_t @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_intptr} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node assertions equality uintptr
@subsection Expecting pointer unsigned integer


@deftypefn {Preprocessor Macro} void cctests_assert_equal_uintptr (cce_destination_t @var{L}, uintptr_t @var{expected}, uintptr_t @var{result})
Assert that @var{expected} equals @var{result}.  If the values are equal: just return.  Otherwise
raise an exception of type @objtype{cctests_condition_assertion_expected_uintptr} by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node process
@chapter Running processes


@menu
* process child only::          Running a test in a subprocess.
* process parent child::        Tests in parent and child processes.
@end menu

@c page
@node process child only
@section Running a test in a subprocess


The following @api{} allows us to run a test function in a subprocess.  Example:

@example
static cctests_child_process_function_t child_function;

void
test_1_1 (cce_destination_t upper_L)
@{
  cctests_call_in_forked_process(upper_L, child_function);
@}

void
child_function (cce_destination_t L)
/* This is run in a subprocess. */
@{
  cctests_assert(L, true);
@}
@end example


@deftypefn {Function Prototype} void cctests_child_process_function_t (cce_destination_t @var{L})
Type of function to call in a subprocess.
@end deftypefn


@deftypefun void cctests_call_in_forked_process (cce_destination_t @var{L}, cctests_child_process_function_t * @var{child_function})
Fork a process:

@itemize
@item
In the child: call @var{child_function}; exit successfully if the function returns; exit with
failure if the function raises an exception.  The child process is terminated with a call to the
standard function @cfunc{_exit}.  The child function might terminate the subprocess by itself.

@item
In the parent: wait for the child termination; assert that the child process terminated
successfully.
@end itemize
@end deftypefun

@c page
@node process parent child
@section Tests in parent and child processes


The following @api{} allows us to run a test function in a child process and a test function in the
parent process.  Example:

@example
static cctests_parent_process_function_t parent_function;
static cctests_child_process_function_t  child_function;

void
test_1_1 (cce_destination_t upper_L)
@{
  cctests_with_parent_and_child_process(upper_L,
     parent_function, child_function);
@}

static void
parent_function (cce_destination_t L, int64_t child_pid)
/* This runs in the parent. */
@{
  cctests_assert(L, true);
@}

static void
child_function (cce_destination_t L)
/* This runs in the child. */
@{
  cctests_assert(L, true);
@}
@end example

This @api{} is especially useful when we want two processes to exchange messages through pipes or
sockets, or to send interprocess signals to each other.


@deftypefn {Function Prototype} void cctests_parent_process_function_t (cce_destination_t @var{L}, int64_t @var{child_pid})
Type of function to call in a parent process.
@end deftypefn


@deftypefn {Function Prototype} void cctests_child_process_function_t (cce_destination_t @var{L})
Type of function to call in a subprocess.
@end deftypefn


@deftypefun void cctests_with_parent_and_child_process (cce_destination_t @var{L}, cctests_parent_process_function_t * @var{parent_function}, cctests_child_process_function_t * @var{child_function})
Fork a process:

@itemize
@item
In the child: run @var{child_function}; exit successfully if the function returns; exit with failure
if the child raises an exception.  The child process is terminated with a call to the standard
function @cfunc{_exit}.  The child function might terminate the subprocess by itself.

@item
In the parent: run @var{parent_function}; wait for the child termination; assert that the child
process terminated successfully; assert that the parent function returned successfully.
@end itemize
@end deftypefun

@c page
@node conditions
@chapter Condition object types


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
#include <cctests.h>

cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_catch_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_body_handlers(L);
@}
@end example

@menu
* conditions base::             Base condition object.
* conditions success::          Signalling test success.
* conditions skipped::          Signalling a skipped test.
* conditions failure::          Signalling test failure.
* conditions expected failure:: Signalling expected test failure.
* conditions assertion::        Signalling failed assertions.
* conditions unreachable::      Signalling execution of unreachable code.
* conditions regex::            Regular expression errors.
* conditions child::            Child subprocess errors.

Convenience condition types

* conditions signal::           Convenience signal.
* conditions signal one::       Convenience signal one.
* conditions signal two::       Convenience signal two.
* conditions signal three::     Convenience signal three.
@end menu

@c page
@node conditions base
@section Base condition object


@cindex Base, exceptional condition
@cindex Exceptional conditions, base


The @dfn{base exceptional--condition object--type} is the base for all the condition types defined
by @value{PACKAGE} related to testing operations; @value{PACKAGE} might raise exceptions not derived
from this type, when an internal error occurs.

We are @strong{not} meant to instantiate condition objects of type @emph{base} (so there is no
@code{new} function), but we can derive new types from it (so there is an @code{init} function).

To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_base(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_base_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_base_t
Type of data structure representing the base exceptional--condition descriptor.  It has the
following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the root descriptor; @xref{conditions root, CCExceptions,
CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_base_t
Type of data structure representing the base exceptional--condition object.  It has the following
public fields:

@table @code
@item cce_condition_root_t root
The parent condition type.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_base_t const * const} cctests_descriptor_base_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_base (cctests_condition_base_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_base_t}.
@end deftypefun


@deftypefun bool cctests_condition_is_base (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_base_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_base_t} we can copy the code in the files:

@example
condition-base-subtype.c
condition-base-subtype-headear.h
condition-base-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_base_subtype_t}.

@c page
@node conditions success
@section Signalling test success


@cindex Test success, exceptional condition
@cindex Exceptional conditions, test success


The @dfn{success exceptional--condition object--type} can be used to signal success in a test
execution; it is not the only way a test can succeed, it is just an option that can be useful in
some special cases.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_success(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_success_t, C, cce_condition(L));
    do_something_with(C);
    cce_run_body_handlers_final(L);
  @} else @{
    cce_run_catch_handlers_final(L);
  @}
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_success_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_success_t
Type of data structure representing the condition object.  It has the following public fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_success_t const * const} cctests_descriptor_success_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_success (cctests_condition_success_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_success_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_success (void)
Return a pointer to exceptional--condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_success (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_success_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_success_t} we can copy the code in the files:

@example
condition-success-subtype.c
condition-success-subtype-headear.h
condition-success-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_success_subtype_t}.

@c page
@node conditions skipped
@section Signalling test skipped


@cindex Test skipped, exceptional condition
@cindex Exceptional conditions, test skipped


The @dfn{skipped exceptional--condition object--type} can be used to signal a skipped test
execution; a skipped test is not a failed test.  We can instantiate this type and also derive new
types from it.  To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_skipped(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_skipped_t, C, cce_condition(L));
    do_something_with(C);
    cce_run_body_handlers_final(L);
  @} else @{
    cce_run_catch_handlers_final(L);
  @}
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_skipped_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_skipped_t
Type of data structure representing the condition object.  It has the following public fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_skipped_t const * const} cctests_descriptor_skipped_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_skipped (cctests_condition_skipped_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_skipped_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_skipped (void)
Return a pointer to exceptional--condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_skipped (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_skipped_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_skipped_t} we can copy the code in the files:

@example
condition-skipped-subtype.c
condition-skipped-subtype-headear.h
condition-skipped-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_skipped_subtype_t}.

@c page
@node conditions failure
@section Signalling test failure


@cindex Test failure, exceptional condition
@cindex Exceptional conditions, test failure


The @dfn{failure exceptional--condition object--type} is used by @value{PACKAGE} to signal failure
in a test execution; this is the base for all the types that signal a test failure.  We can
instantiate this type and also derive new types from it.  To catch this exceptional condition we can
do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_failure(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_failure_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_failure_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_failure_t
Type of data structure representing the condition object.  It has the following public fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_failure_t const * const} cctests_descriptor_failure_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_failure (cctests_condition_failure_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_failure_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_failure (void)
Return a pointer to exceptional--condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_failure (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_failure_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_failure_t} we can copy the code in the files:

@example
condition-failure-subtype.c
condition-failure-subtype-headear.h
condition-failure-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_failure_subtype_t}.

@c page
@node conditions expected failure
@section Signalling expected test failure


@cindex Expected failure, exceptional condition
@cindex Exceptional conditions, expected failure


The @dfn{expected failure exceptional--condition object--type} is used by @value{PACKAGE} to signal
an expected failure in a test function.  We can instantiate this type and also derive new types from
it.  To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_expected_failure(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_expected_failure_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_expected_failure_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_failure_ptr},
@ref{conditions failure, Signalling test failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_expected_failure_t
Type of data structure representing the exceptional--condition object.
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_expected_failure_t const * const} cctests_descriptor_expected_failure_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_expected_failure (cctests_condition_expected_failure_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_expected_failure_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_expected_failure (cce_destination_t @var{L})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_expected_failure (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_expected_failure_t}; otherwise
return @cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_expected_failure_t} we can copy the code in the
files:

@example
condition-expected-failure-subtype.c
condition-expected-failure-subtype-headear.h
condition-expected-failure-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_expected_failure_subtype_t}.

@c page
@node conditions assertion
@section Signalling failed assertions


@menu
* conditions assertion base::      Basic assertions.
* conditions assertion expected::  Expected value assertions.
* conditions assertion asciiz::    Expected @asciiz{} assertions.
* conditions assertion ascii::     Expected @ascii{} assertions.
* conditions assertion chars::     Expected characters assertions.
* conditions assertion uchars::    Expected unsigned characters
                                   assertions.
* conditions assertion shorts::    Expected signed short integers
                                   assertions.
* conditions assertion ushorts::   Expected unsigned short integers
                                   assertions.
* conditions assertion ints::      Expected signed integers assertions.
* conditions assertion uints::     Expected unsigned integers assertions.
* conditions assertion longs::     Expected signed long integers assertions.
* conditions assertion ulongs::    Expected unsigned long integers assertions.
* conditions assertion llongs::    Expected signed long long integers
                                   assertions.
* conditions assertion ullongs::   Expected unsigned long long integers
                                   assertions.
* conditions assertion int8::      Expected signed 8-bit integers assertions.
* conditions assertion uint8::     Expected unsigned 8-bit integers
                                   assertions.
* conditions assertion int16::     Expected signed 16-bit integers
                                   assertions.
* conditions assertion uint16::    Expected unsigned 16-bit integers
                                   assertions.
* conditions assertion int32::     Expected signed 32-bit integers
                                   assertions.
* conditions assertion uint32::    Expected unsigned 32-bit integers
                                   assertions.
* conditions assertion int64::     Expected signed 64-bit integers
                                   assertions.
* conditions assertion uint64::    Expected unsigned 64-bit integers assertions.
* conditions assertion float::     Expected single--precision floating point
                                   assertions.
* conditions assertion double::    Expected double--precision floating point
                                   assertions.
* conditions assertion ssize::     Expected signed size integer.
* conditions assertion usize::     Expected unsigned size integer.
* conditions assertion pointer::   Expected pointer.
* conditions assertion ptrdiff::   Expected pointer difference.
* conditions assertion intptr::    Expected pointer signed integer.
* conditions assertion uintptr::   Expected pointer unsigned integer.
@end menu

@c ------------------------------------------------------------------------

@macro ConditionAssertionExpected{TYPE, TYPENAME, TYPEDESCR}
@cindex Failed expected \TYPEDESCR\ assertion, exceptional condition
@cindex Exceptional conditions, failed expected \TYPEDESCR\ assertion


The @dfn{expected \TYPEDESCR\ assertion exceptional--condition object--type} is used by
@value{PACKAGE} to signal failure in an asserting that a specific \TYPEDESCR\ value was expected as
result of an expression.  We can only derive new types from it and instantiate it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_assertion_expected_\TYPENAME\(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_assertion_expected_\TYPENAME\_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_assertion_expected_\TYPENAME\_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_assertion_expected_value_ptr}, @ref{conditions assertion expected, Expected
value assertions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_assertion_expected_\TYPENAME\_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_assertion_expected_value_t assertion_expected_value
The base value.

@item \TYPE\ expected
The expected value.

@item \TYPE\ result
The resulting value.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_assertion_expected_\TYPENAME\_t const * const} cctests_descriptor_assertion_expected_\TYPENAME\_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_assertion_expected_\TYPENAME\ (cce_destination_t @var{L}, cctests_condition_assertion_expected_\TYPENAME\_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, \TYPE\ @var{expected}, \TYPE\ @var{result})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_assertion_expected_\TYPENAME\_t}.
If an error occurs building the instance: raise an exception by performing a non--local exit to
@var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.
@end deftypefun


@deftypefun void cctests_condition_new_assertion_expected_\TYPENAME\ (cce_destination_t @var{L}, cctests_condition_assertion_expected_\TYPENAME\_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, \TYPE\ @var{expected}, \TYPE\ @var{result})
Build and return a new exceptional condition object.  If an error occurs building the instance:
raise an exception by performing a non--local exit to @var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.
@end deftypefun


@deftypefun bool cctests_condition_is_assertion_expected_\TYPENAME\ (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_assertion_expected_\TYPENAME\_t};
otherwise return @cfalse{}.
@end deftypefun
@end macro

@c page
@node conditions assertion base
@subsection Basic assertions


@cindex Failed assertion, exceptional condition
@cindex Exceptional conditions, failed assertion


The @dfn{assertion exceptional--condition object--type} is used by @value{PACKAGE} to signal failure
in an assertion verification, for example by @cfunc{cctests_assertion}.  We can instantiate this
type and also derive new types from it.  To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_assertion(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_assertion_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_assertion_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_failure_ptr},
@ref{conditions failure, Signalling test failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_assertion_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_failure_t failure
The condition object's base values.

@item char const * expr
Pointer to a statically allocated @asciiz{} string representing the failed assertion's expression.

@item char const * filename
Pointer to a statically allocated @asciiz{} string representing the pathname of the source file in
which the failed assertion is located.  This value is meant to be generated with the preprocessor
macro @code{__FILE__}.

@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function in which
the failed assertion is located.  This value is meant to be generated with the preprocessor macro
@code{__func__}.

@item int linenum
The line number in the source file in which the failed assertion is located.  This value is meant to
be generated with the preprocessor macro @code{__LINE__}.

@item char const * dynamic_string
This is either @cnull{} or a pointer to an @asciiz{} message string allocated using the standard
allocator.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_assertion_t const * const} cctests_descriptor_assertion_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_assertion (cctests_condition_assertion_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
@deftypefunx void cctests_condition_init_assertion_msg (cctests_condition_assertion_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, char const * @var{message})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_assertion_t}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are @strong{not} duplicated.
The argument @var{message} is either @cnull{} or a pointer to an @asciiz{} message string allocated
using the standard allocator; the ownership of this string is transferred to the
exceptional--condition object.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_assertion (cce_destination_t @var{L}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
@deftypefunx {cce_condition_t const *} cctests_condition_new_assertion_msg (cce_destination_t @var{L}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, char const * @var{message})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are @strong{not} duplicated.
The argument @var{message} is either @cnull{} or a pointer to an @asciiz{} message string allocated
using the standard allocator; the ownership of this string is transferred to the
exceptional--condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_assertion (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_assertion_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_assertion_t} we can copy the code in the files:

@example
condition-assertion-subtype.c
condition-assertion-subtype-headear.h
condition-assertion-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_assertion_subtype_t}.

@c page
@node conditions assertion expected
@subsection Expected value assertions


@cindex Failed expected value assertion, exceptional condition
@cindex Exceptional conditions, failed expected assertion


The @dfn{expected--value assertion exceptional--condition object--type} is used by @value{PACKAGE}
to signal failure in an asserting that a certain value was expected as result of an expression.  We
can only derive new types from it, @strong{not} instantiate it.  To catch this exceptional condition
we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_assertion_expected_value(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_assertion_expected_value_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_assertion_expected_value_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_assertion_ptr},
@ref{conditions assertion base, Basic assertions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_assertion_expected_value_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_assertion_t assertion
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_assertion_expected_value_t const * const} cctests_descriptor_assertion_expected_value_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_assertion_expected_value (cctests_condition_assertion_expected_value_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_assertion_expected_value_t}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.  The
strings referenced by @var{expected} and @var{result} are duplicated.
@end deftypefun


@deftypefun bool cctests_condition_is_assertion_expected_value (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_assertion_expected_value_t};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions assertion asciiz
@subsection Expected @asciiz{} assertions


@cindex Failed expected @asciiz{} assertion, exceptional condition
@cindex Exceptional conditions, failed expected @asciiz{} assertion


The @dfn{expected @asciiz{} assertion exceptional--condition object--type} is used by
@value{PACKAGE} to signal failure in an asserting that an @asciiz{} string was expected as result of
an expression.  We can only derive new types from it, @strong{not} instantiate it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_assertion_expected_asciiz(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_assertion_expected_asciiz_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_assertion_expected_asciiz_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_assertion_expected_value_ptr}, @ref{conditions assertion expected, Expected
value assertions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_assertion_expected_asciiz_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_assertion_expected_value_t assertion_expected_value
The base value.

@item char * expected
A copy of the expected value, an @asciiz{} string.  This object is responsible for the memory
allocation.

@item char * result
A copy of the resulting value, an @asciiz{} string.  This object is responsible for the memory
allocation.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_assertion_expected_asciiz_t const * const} cctests_descriptor_assertion_expected_asciiz_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_assertion_expected_asciiz (cce_destination_t @var{L}, cctests_condition_assertion_expected_asciiz_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, char const * @var{expected}, char const * @var{result})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_assertion_expected_asciiz_t}.
If an error occurs building the instance: raise an exception by performing a non--local exit to
@var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.  The
strings referenced by @var{expected} and @var{result} are duplicated.
@end deftypefun


@deftypefun void cctests_condition_new_assertion_expected_asciiz (cce_destination_t @var{L}, cctests_condition_assertion_expected_asciiz_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, char const * @var{expected}, char const * @var{result})
Build and return a new exceptional condition object.  If an error occurs building the instance:
raise an exception by performing a non--local exit to @var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.  The
strings referenced by @var{expected} and @var{result} are duplicated.
@end deftypefun


@deftypefun bool cctests_condition_is_assertion_expected_asciiz (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_assertion_expected_asciiz_t};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions assertion ascii
@subsection Expected @ascii{} assertions


@cindex Failed expected @ascii{} assertion, exceptional condition
@cindex Exceptional conditions, failed expected @ascii{} assertion


The @dfn{expected @ascii{} assertion exceptional--condition object--type} is used by
@value{PACKAGE} to signal failure in an asserting that an @ascii{} string was expected as result of
an expression.  We can only derive new types from it, @strong{not} instantiate it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_assertion_expected_ascii(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_assertion_expected_ascii_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_assertion_expected_ascii_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_assertion_expected_value_ptr}, @ref{conditions assertion expected, Expected
value assertions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_assertion_expected_ascii_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_assertion_expected_value_t assertion_expected_value
The base value.

@item char * expected
A copy of the expected value, an @asciiz{} string.  This object is responsible for the memory
allocation.

@item char * result
A copy of the resulting value, an @ascii{} string.  This object is responsible for the memory
allocation.

@item size_t result_len
The number of characters in the string referenced by @var{result}.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_assertion_expected_ascii_t const * const} cctests_descriptor_assertion_expected_ascii_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_assertion_expected_ascii (cce_destination_t @var{L}, cctests_condition_assertion_expected_ascii_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, char const * @var{expected}, char const * @var{result}, size_t @var{result_len})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_assertion_expected_ascii_t}.
If an error occurs building the instance: raise an exception by performing a non--local exit to
@var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.  The
strings referenced by @var{expected} and @var{result} are duplicated.
@end deftypefun


@deftypefun void cctests_condition_new_assertion_expected_ascii (cce_destination_t @var{L}, cctests_condition_assertion_expected_ascii_t * @var{C}, char const * @var{expr}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum}, char const * @var{expected}, char const * @var{result}, size_t @var{result_len})
Build and return a new exceptional condition object.  If an error occurs building the instance:
raise an exception by performing a non--local exit to @var{L}.

The strings referenced by @var{expr}, @var{filename}, @var{funcname} are not duplicated.  The
strings referenced by @var{expected} and @var{result} are duplicated.
@end deftypefun


@deftypefun bool cctests_condition_is_assertion_expected_ascii (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_assertion_expected_ascii_t};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions assertion chars
@subsection Expected characters assertions


@ConditionAssertionExpected{signed char, char, signed character}

@c ------------------------------------------------------------------------

@node conditions assertion uchars
@subsection Expected unsigned characters assertions


@ConditionAssertionExpected{unsigned char, uchar, unsigned character}

@c ------------------------------------------------------------------------

@node conditions assertion shorts
@subsection Expected signed short integers assertions


@ConditionAssertionExpected{signed short int, short, signed short integer}

@c ------------------------------------------------------------------------

@node conditions assertion ushorts
@subsection Expected unsigned short integers assertions


@ConditionAssertionExpected{unsigned short int, ushort, unsigned short integer}

@c ------------------------------------------------------------------------

@node conditions assertion ints
@subsection Expected signed integers assertions


@ConditionAssertionExpected{signed int, int, signed integer}

@c ------------------------------------------------------------------------

@node conditions assertion uints
@subsection Expected unsigned integers assertions


@ConditionAssertionExpected{unsigned int, uint, unsigned integer}

@c ------------------------------------------------------------------------

@node conditions assertion longs
@subsection Expected signed long integers assertions


@ConditionAssertionExpected{signed long, long, signed long integer}

@c ------------------------------------------------------------------------

@node conditions assertion ulongs
@subsection Expected unsigned long integers assertions


@ConditionAssertionExpected{unsigned long int, ulong, unsigned long integer}

@c ------------------------------------------------------------------------

@node conditions assertion llongs
@subsection Expected signed long long integers assertions


@ConditionAssertionExpected{signed long long int, llong, signed long long integer}

@c ------------------------------------------------------------------------

@node conditions assertion ullongs
@subsection Expected unsigned long long integers assertions


@ConditionAssertionExpected{unsigned long long int, ullong, unsigned long long integer}

@c ------------------------------------------------------------------------

@node conditions assertion int8
@subsection Expected signed 8-bit integers assertions


@ConditionAssertionExpected{int8_t, int8, signed 8-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion uint8
@subsection Expected unsigned 8-bit integers assertions


@ConditionAssertionExpected{uint8_t, uint8, unsigned 8-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion int16
@subsection Expected signed 16-bit integers assertions


@ConditionAssertionExpected{int16_t, int16, signed 16-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion uint16
@subsection Expected unsigned 16-bit integers assertions


@ConditionAssertionExpected{uint16_t, uint16, unsigned 16-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion int32
@subsection Expected signed 32-bit integers assertions


@ConditionAssertionExpected{int32_t, int32, signed 32-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion uint32
@subsection Expected unsigned 32-bit integers assertions


@ConditionAssertionExpected{uint32_t, uint32, unsigned 32-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion int64
@subsection Expected signed 64-bit integers assertions


@ConditionAssertionExpected{int64_t, int64, signed 64-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion uint64
@subsection Expected unsigned 64-bit integers assertions


@ConditionAssertionExpected{uint64_t, uint64, unsigned 64-bit integer}

@c ------------------------------------------------------------------------

@node conditions assertion float
@subsection Expected single--precision floating point assertions


@ConditionAssertionExpected{float, float, single--precision floating point}

@c ------------------------------------------------------------------------

@node conditions assertion double
@subsection Expected double--precision floating point assertions


@ConditionAssertionExpected{double, double, double--precision floating point}

@c ------------------------------------------------------------------------

@node conditions assertion ssize
@subsection Expected signed size integer

@ConditionAssertionExpected{ssize_t, ssize, signed integer size}

@c ------------------------------------------------------------------------

@node conditions assertion usize
@subsection Expected unsigned size integer

@ConditionAssertionExpected{size_t, size, unsigned integer size}

@c ------------------------------------------------------------------------

@node conditions assertion pointer
@subsection Expected pointer

@ConditionAssertionExpected{void *, pointer, pointer}

@c ------------------------------------------------------------------------

@node conditions assertion ptrdiff
@subsection Expected pointer difference

@ConditionAssertionExpected{ptrdiff_t, ptrdiff, pointer difference}

@c ------------------------------------------------------------------------

@node conditions assertion intptr
@subsection Expected pointer signed integer

@ConditionAssertionExpected{intptr_t, intptr, pointer signed integer}

@c ------------------------------------------------------------------------

@node conditions assertion uintptr
@subsection Expected pointer unsigned integer

@ConditionAssertionExpected{uintptr_t, uintptr, pointer unsigned integer}

@c page
@node conditions unreachable
@section Signalling execution of unreachable code


@cindex Unreachable code, exceptional condition
@cindex Exceptional conditions, Unreachable code


We can use the @dfn{unreachable code exceptional--condition object--type} to signal the execution of
unreachable code; this happens when we know that a function call must raise an exception, but it for
some erroneous reason it does not.  We can instantiate this type and also derive new types from it.
To catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_unreachable(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_unreachable_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_unreachable_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_failure_ptr},
@ref{conditions failure, Signalling test failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_unreachable_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_failure_t failure
The condition object's base values.

@item char const * filename
Pointer to a statically allocated @asciiz{} string representing the pathname of the source file in
which the unreachable code is located.  This value is meant to be generated with the preprocessor
macro @code{__FILE__}.

@item char const * funcname
Pointer to a statically allocated @asciiz{} string representing the name of the function in which
the unreachable code is located.  This value is meant to be generated with the preprocessor macro
@code{__func__}.

@item int linenum
The line number in the source file in which the unreachable code is located.  This value is meant to
be generated with the preprocessor macro @code{__LINE__}.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_unreachable_t const * const} cctests_descriptor_unreachable_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_unreachable (cctests_condition_unreachable_t * @var{C}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_unreachable_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_unreachable (cce_destination_t @var{L}, char const * @var{filename}, char const * @var{funcname}, int @var{linenum})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_unreachable (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_unreachable_t}; otherwise return
@cfalse{}.
@end deftypefun


@deftypefn {Preprocessor Macro} cctests_raise_unreachable (cce_destination_t @var{L})
Raise an exceptional condition of type @objtype{cctests_condition_unreachable_t} by expanding into:

@example
cce_raise((L), cctests_condition_new_unreachable((L), __FILE__, __func__, __LINE__))
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_unreachable_t} we can copy the code in the
files:

@example
condition-unreachable-subtype.c
condition-unreachable-subtype-headear.h
condition-unreachable-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_unreachable_subtype_t}.

@c page
@node conditions regex
@section Regular expression errors


@value{PACKAGE} uses @posix{} regular expressions to allow the user to select which tests and test
groups to run.

@menu
* conditions regex error::      Base regular expression errors.
* conditions regex comp::       Regular expression compilation errors.
@end menu

@c page
@node conditions regex error
@subsection Base regular expression errors


@cindex Base regular expression error, exceptional condition
@cindex Regular expression error, base exceptional condition
@cindex Exceptional conditions, base regular expression error


The @dfn{regex error exceptional--condition object--type} is used by @value{PACKAGE} to represent an
error related to the use of @posix{} regular expressions; this type is the base for more specialised
types.  We can instantiate this type and also derive new types from it.  To catch this exceptional
condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_regex_error(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_regex_error_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_regex_error_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_runtime_error_ptr},
@xref{conditions run-time error, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} cctests_condition_regex_error_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
The condition object's base values.

@item int errcode
The error code as defined by the @posix{} regex @api{}.

@item char error_message[1024]
An array holding the @asciiz{} representation of the error description generated by
@cfunc{regerror}.  If the message is longer than @math{1024} characters: it is truncated.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_regex_error_t const * const} cctests_descriptor_regex_error_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_regex_error (cctests_condition_regex_error_t * @var{C}, int @var{errcode})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_regex_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_regex_error (cce_destination_t @var{L}, int @var{errcode})
Return a pointer to exceptional condition object.  If an error occurs building the condition object:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_regex_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_descriptor_regex_error_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_regex_error_t} we can copy the code in the
files:

@example
condition-regex-error-subtype.c
condition-regex-error-subtype-headear.h
condition-regex-error-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_regex_error_subtype_t}.

@c page
@node conditions regex comp
@subsection Regular expression compilation errors


@cindex Regular expression compilation error, exceptional condition
@cindex Exceptional conditions, regular expression compilation error


The @dfn{regex compilation error exceptional--condition object--type} is used by @value{PACKAGE} to
represent an error compiling a @posix{} regular expressions; it is used when calling the standard
function @cfunc{regcomp}.  We can instantiate this type and also derive new types from it.  To catch
this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_regex_compilation_error(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_regex_compilation_error_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_regex_compilation_error_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_regex_error_ptr}, @ref{conditions regex error, Base regular expression
errors}.
@end deftp


@deftp {Struct Typedef} cctests_condition_regex_compilation_error_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_regex_error_t regex_error
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_regex_compilation_error_t const * const} cctests_descriptor_regex_compilation_error_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_regex_compilation_error (cctests_condition_regex_compilation_error_t * @var{C}, int @var{errcode})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_regex_compilation_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_regex_compilation_error (cce_destination_t @var{L}, int @var{errcode})
Return a pointer to exceptional condition object.  If an error occurs building the condition object:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_regex_compilation_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_descriptor_regex_compilation_error_t};
otherwise return @cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_regex_compilation_error_t} we can copy the code
in the files:

@example
condition-regex-compilation-error-subtype.c
condition-regex-compilation-error-subtype-headear.h
condition-regex-compilation-error-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_regex_compilation_error_subtype_t}.

@c page
@node conditions child
@section Child subprocess errors


@menu
* conditions child failure::    Child failure.
* conditions child abnormal::   Child abnormal termination.
* conditions child status::     Child failure exit status.
@end menu

@c page
@node conditions child failure
@subsection Child failure


@cindex Child failure, exceptional condition
@cindex Exceptional conditions, child failure


We can use the @dfn{child failure exceptional--condition object--type} to signal an error in the
execution a child process.  We can instantiate this type and also derive new types from it.  To
catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_child_failure(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_child_failure_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_child_failure_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_failure_ptr},
@ref{conditions failure, Signalling test failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_child_failure_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_failure_t failure
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_child_failure_t const * const} cctests_descriptor_child_failure_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_child_failure (cctests_condition_child_failure_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_child_failure_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_child_failure (cce_destination_t @var{L})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_child_failure (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_child_failure_t}; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions child abnormal
@subsection Child abnormal termination


@cindex Child abnormal termination, exceptional condition
@cindex Exceptional conditions, child abnormal termination


We can use the @dfn{child abnormal termination exceptional--condition object--type} to signal an
abnormal termination in the execution a child process; this happens when the process is @strong{not}
terminated by a call to the @cfunc{exit} function or by simply returning from the @cfunc{main}
function.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_child_abnormal_termination(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_child_abnormal_termination_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_child_abnormal_termination_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_child_failure_ptr}, @ref{conditions child failure, Child failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_child_abnormal_termination_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_child_failure_t child_failure
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_child_abnormal_termination_t const * const} cctests_descriptor_child_abnormal_termination_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_child_abnormal_termination (cctests_condition_child_abnormal_termination_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_child_abnormal_termination_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_child_abnormal_termination (cce_destination_t @var{L})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_child_abnormal_termination (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_child_abnormal_termination_t};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions child status
@subsection Child failure exit status


@cindex Child failure exit status, exceptional condition
@cindex Exceptional conditions, child failure exit status


We can use the @dfn{child failure exit status exceptional--condition object--type} to signal the
termination of a child process with a non--zero status; this happens when the process is terminated
by a call to the @cfunc{exit} function with a non--zero argument or by simply returning non--zero
from the @cfunc{main} function.  We can instantiate this type and also derive new types from it.  To
catch this exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_child_failure_exit_status(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_child_failure_exit_status_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_child_failure_exit_status_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{cctests_descriptor_child_failure_ptr}, @ref{conditions child failure, Child failure}.
@end deftp


@deftp {Struct Typedef} cctests_condition_child_failure_exit_status_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_child_failure_t child_failure
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_child_failure_exit_status_t const * const} cctests_descriptor_child_failure_exit_status_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_child_failure_exit_status (cctests_condition_child_failure_exit_status_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_child_failure_exit_status_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_child_failure_exit_status (cce_destination_t @var{L})
Return a pointer to exceptional condition object.  If an error occurs building the instance: raise
an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool cctests_condition_is_child_failure_exit_status (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_child_failure_exit_status_t};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions signal
@section Convenience signal


@cindex Signal, exceptional condition
@cindex Exceptional conditions, signal


We can use the @dfn{signal exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample

If we raise an exception of this type, or one of its sub--types, then we must also catch it before
it reaches @value{PACKAGE}'s functions; otherwise the currently executed test will be considered
failed in an abnormal way.


@deftp {Struct Typedef} cctests_descriptor_signal_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_base_ptr},
@ref{conditions base, Base condition object}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_base_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_t const * const} cctests_descriptor_signal_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_signal (cctests_condition_signal_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_t} we can copy the code in the files:

@example
condition-signal-subtype.c
condition-signal-subtype-headear.h
condition-signal-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_subtype_t}.

@c page
@node conditions signal one
@section Convenience signal one


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


We can use the @dfn{signal--1 exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_1(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_1_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_signal_1_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_signal_ptr},
@ref{conditions signal, Convenience signal}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_1_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_signal_t signal
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_1_t const * const} cctests_descriptor_signal_1_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_signal_1 (cctests_condition_signal_1_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_1_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_1 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_1 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_1_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_1_t} we can copy the code in the files:

@example
condition-signal-1-subtype.c
condition-signal-1-subtype-headear.h
condition-signal-1-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_1_subtype_t}.

@c page
@node conditions signal two
@section Convenience signal two


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


We can use the @dfn{signal--2 exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[2];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_2(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_2_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_signal_2_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_signal_ptr},
@ref{conditions signal, Convenience signal}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_2_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_signal_t signal
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_2_t const * const} cctests_descriptor_signal_2_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_signal_2 (cctests_condition_signal_2_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_2_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_2 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_2 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_2_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_2_t} we can copy the code in the files:

@example
condition-signal-2-subtype.c
condition-signal-2-subtype-headear.h
condition-signal-2-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_2_subtype_t}.

@c page
@node conditions signal three
@section Convenience signal three


@cindex Signal one, exceptional condition
@cindex Exceptional conditions, signal one


We can use the @dfn{signal--3 exceptional--condition object--type} to signal some special test
condition.  We can instantiate this type and also derive new types from it.  To catch this
exceptional condition we can do:

@smallexample
cce_location_t        L[3];

if (cce_location(L)) @{
  if (cctests_condition_is_signal_3(cce_condition(L))) @{
    CCTESTS_PC(cctests_condition_signal_3_t, C, cce_condition(L));
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end smallexample


@deftp {Struct Typedef} cctests_descriptor_signal_3_t
Type of data structure representing the exceptional--condition descriptor.  It has the following
public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cctests_descriptor_signal_ptr},
@ref{conditions signal, Convenience signal}.
@end deftp


@deftp {Struct Typedef} cctests_condition_signal_3_t
Type of data structure representing the exceptional--condition object.  It has the following public
fields:

@table @code
@item cctests_condition_signal_t signal
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {cctests_descriptor_signal_3_t const * const} cctests_descriptor_signal_3_ptr
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun void cctests_condition_init_signal_3 (cctests_condition_signal_3_t * @var{C})
Initialisation function for the condition object.  This function is meant to be called from the
initialisation function of sub--types of @objtype{cctests_condition_signal_3_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} cctests_condition_new_signal_3 (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool cctests_condition_is_signal_3 (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @objtype{cctests_condition_signal_3_t}; otherwise return
@cfalse{}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Sub--typing example


To define a sub--type of @objtype{cctests_condition_signal_3_t} we can copy the code in the files:

@example
condition-signal-3-subtype.c
condition-signal-3-subtype-headear.h
condition-signal-3-subtype-body.c
@end example

@noindent
under the @file{tests} directory of the source distribution; the code defines a new
condition--object type @objtype{my_condition_signal_3_subtype_t}.

@c page
@node utils
@chapter Utility definitions


@defmac CCTESTS_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCTESTS_PC(cctests_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
cctests_descriptor_test_failure_t * C = \
   (cctests_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCTESTS_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@node constants
@chapter Useful constants.


@menu
* constants limits::            Limits of known integer types.
@end menu

@c page
@node constants limits
@section Limits of known integer types


@menu
* constants limits chars::      Character limits.
* constants limits shorts::     Short integers limits.
* constants limits ints::       Integers limits.
* constants limits long::       Long limits.
* constants limits llong::      Long long limits.
* constants limits int8::       8-bit integers limits.
* constants limits int16::      16-bit integers limits.
* constants limits int32::      32-bit integers limits.
* constants limits int64::      64-bit integers limits.
* constants limits ssize::      Signed integer size limits.
* constants limits usize::      Unsigned integer size limits.
* constants limits ptrdiff::    Pointer difference integers limits.
* constants limits intptr::     Pointer signed integer limits.
* constants limits uintptr::    Pointer unsigned integer limits.
@end menu

@c page
@node constants limits chars
@subsection Character limits


@deftypevr Constant {unsigned char const} CCTESTS_UCHAR_MAX
Maximum value representable by the type @objtype{unsigned char}.
@end deftypevr


@deftypevr Constant {unsigned char const} CCTESTS_UCHAR_MIN
Minimum value representable by the type @objtype{unsigned char}.
@end deftypevr


@deftypevr Constant {signed char const} CCTESTS_CHAR_MAX
Maximum value representable by the type @objtype{signed char}.
@end deftypevr


@deftypevr Constant {signed char const} CCTESTS_CHAR_MIN
Minimum value representable by the type @objtype{signed char}.
@end deftypevr

@c page
@node constants limits shorts
@subsection Short integers limits


@deftypevr Constant {unsigned short const} CCTESTS_USHORT_MAX
Maximum value representable by the type @objtype{unsigned short}.
@end deftypevr


@deftypevr Constant {unsigned short const} CCTESTS_USHORT_MIN
Minimum value representable by the type @objtype{unsigned short}.
@end deftypevr


@deftypevr Constant {signed short const} CCTESTS_SHORT_MAX
Maximum value representable by the type @objtype{signed short}.
@end deftypevr


@deftypevr Constant {signed short const} CCTESTS_SHORT_MIN
Minimum value representable by the type @objtype{signed short}.
@end deftypevr

@c page
@node constants limits ints
@subsection Integers limits


@deftypevr Constant {unsigned int const} CCTESTS_UINT_MAX
Maximum value representable by the type @objtype{unsigned int}.
@end deftypevr


@deftypevr Constant {unsigned int const} CCTESTS_UINT_MIN
Minimum value representable by the type @objtype{unsigned int}.
@end deftypevr


@deftypevr Constant {signed int const} CCTESTS_INT_MAX
Maximum value representable by the type @objtype{signed int}.
@end deftypevr


@deftypevr Constant {signed int const} CCTESTS_INT_MIN
Minimum value representable by the type @objtype{signed int}.
@end deftypevr

@c page
@node constants limits long
@subsection Long limits


@deftypevr Constant {unsigned long const} CCTESTS_ULONG_MAX
Maximum value representable by the type @objtype{unsigned long}.
@end deftypevr


@deftypevr Constant {unsigned long const} CCTESTS_ULONG_MIN
Minimum value representable by the type @objtype{unsigned long}.
@end deftypevr


@deftypevr Constant {signed long const} CCTESTS_LONG_MAX
Maximum value representable by the type @objtype{signed long}.
@end deftypevr


@deftypevr Constant {signed long const} CCTESTS_LONG_MIN
Minimum value representable by the type @objtype{signed long}.
@end deftypevr

@c page
@node constants limits llong
@subsection Long long limits


@deftypevr Constant {unsigned long long const} CCTESTS_ULLONG_MAX
Maximum value representable by the type @objtype{unsigned long long}.
@end deftypevr


@deftypevr Constant {unsigned long long const} CCTESTS_ULLONG_MIN
Minimum value representable by the type @objtype{unsigned long long}.
@end deftypevr


@deftypevr Constant {signed long long const} CCTESTS_LLONG_MAX
Maximum value representable by the type @objtype{signed long long}.
@end deftypevr


@deftypevr Constant {signed long long const} CCTESTS_LLONG_MIN
Minimum value representable by the type @objtype{signed long long}.
@end deftypevr

@c page
@node constants limits int8
@subsection 8-bit integers limits


@deftypevr Constant {uint8_t const} CCTESTS_UINT8_MAX
Maximum value representable by the type @objtype{uint8_t}.
@end deftypevr


@deftypevr Constant {uint8_t const} CCTESTS_UINT8_MIN
Minimum value representable by the type @objtype{uint8_t}.
@end deftypevr


@deftypevr Constant {int8_t const} CCTESTS_INT8_MAX
Maximum value representable by the type @objtype{int8_t}.
@end deftypevr


@deftypevr Constant {int8_t const} CCTESTS_INT8_MIN
Minimum value representable by the type @objtype{int8_t}.
@end deftypevr

@c page
@node constants limits int16
@subsection 16-bit integers limits


@deftypevr Constant {uint16_t const} CCTESTS_UINT16_MAX
Maximum value representable by the type @objtype{uint16_t}.
@end deftypevr


@deftypevr Constant {uint16_t const} CCTESTS_UINT16_MIN
Minimum value representable by the type @objtype{uint16_t}.
@end deftypevr


@deftypevr Constant {int16_t const} CCTESTS_INT16_MAX
Maximum value representable by the type @objtype{int16_t}.
@end deftypevr


@deftypevr Constant {int16_t const} CCTESTS_INT16_MIN
Minimum value representable by the type @objtype{int16_t}.
@end deftypevr

@c page
@node constants limits int32
@subsection 32-bit integers limits


@deftypevr Constant {uint32_t const} CCTESTS_UINT32_MAX
Maximum value representable by the type @objtype{uint32_t}.
@end deftypevr


@deftypevr Constant {uint32_t const} CCTESTS_UINT32_MIN
Minimum value representable by the type @objtype{uint32_t}.
@end deftypevr


@deftypevr Constant {int32_t const} CCTESTS_INT32_MAX
Maximum value representable by the type @objtype{int32_t}.
@end deftypevr


@deftypevr Constant {int32_t const} CCTESTS_INT32_MIN
Minimum value representable by the type @objtype{int32_t}.
@end deftypevr

@c page
@node constants limits int64
@subsection 64-bit integers limits


@deftypevr Constant {uint64_t const} CCTESTS_UINT64_MAX
Maximum value representable by the type @objtype{uint64_t}.
@end deftypevr


@deftypevr Constant {uint64_t const} CCTESTS_UINT64_MIN
Minimum value representable by the type @objtype{uint64_t}.
@end deftypevr


@deftypevr Constant {int64_t const} CCTESTS_INT64_MAX
Maximum value representable by the type @objtype{int64_t}.
@end deftypevr


@deftypevr Constant {int64_t const} CCTESTS_INT64_MIN
Minimum value representable by the type @objtype{int64_t}.
@end deftypevr

@c page
@node constants limits ssize
@subsection Signed integer size limits


@deftypevr Constant {ssize_t const} CCTESTS_SSIZE_MAX
Maximum value representable by the type @objtype{ssize_t}.
@end deftypevr


@deftypevr Constant {ssize_t const} CCTESTS_SSIZE_MIN
Minimum value representable by the type @objtype{ssize_t}.
@end deftypevr

@c page
@node constants limits usize
@subsection Unsigned integer size limits


@deftypevr Constant {size_t const} CCTESTS_SIZE_MAX
Maximum value representable by the type @objtype{size_t}.
@end deftypevr


@deftypevr Constant {size_t const} CCTESTS_SIZE_MIN
Minimum value representable by the type @objtype{size_t}.
@end deftypevr

@c page
@node constants limits ptrdiff
@subsection Pointer difference integers limits


@deftypevr Constant {ptrdiff_t const} CCTESTS_PTRDIFF_MAX
Maximum value representable by the type @objtype{ptrdiff_t}.
@end deftypevr


@deftypevr Constant {ptrdiff_t const} CCTESTS_PTRDIFF_MIN
Minimum value representable by the type @objtype{ptrdiff_t}.
@end deftypevr

@c page
@node constants limits intptr
@subsection Pointer signed integer limits


@deftypevr Constant {intptr_t const} CCTESTS_INTPTR_MAX
Maximum value representable by the type @objtype{intptr_t}.
@end deftypevr


@deftypevr Constant {intptr_t const} CCTESTS_INTPTR_MIN
Minimum value representable by the type @objtype{intptr_t}.
@end deftypevr

@c page
@node constants limits uintptr
@subsection Pointer unsigned integer limits


@deftypevr Constant {uintptr_t const} CCTESTS_UINTPTR_MAX
Maximum value representable by the type @objtype{uintptr_t}.
@end deftypevr


@deftypevr Constant {uintptr_t const} CCTESTS_UINTPTR_MIN
Minimum value representable by the type @objtype{uintptr_t}.
@end deftypevr

@c page
@node debugging
@chapter Debugging facilities


@value{PACKAGE} implements some facilities to print common debugging messages from test programs.


@defmac CCTESTS_DEBUGGING
Enables the debugging facilities when it is defined to @samp{1} before the inclusion of
@file{cctests.h}.  By default, or if this symbol is defined to @samp{0}: the macros documented below
will expand to the empty expression.
@end defmac


@deftypefn {Preprocessor Macro} {char const *} cctests_debug_question (@var{EXPR})
When debugging is enabled, expand to:

@example
((@var{EXPR})? "yes" : "no")
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} void cctests_debug_print (char const * @var{template}, @dots{})
When debugging is enabled, expand to an expression that prints to @code{cctests_log_stream} a
debugging message.  The message is composed of the current position in the source code and the
result of formatting @var{template} with the given, optional, arguments; formatting works like it
does for @cfunc{printf}.
@end deftypefn


@deftypefn {Preprocessor Macro} void cctests_debug_mark (void)
When debugging is enabled, expand to:

@example
cctests_debug_print("mark")
@end example
@end deftypefn

@c page
@node automake
@chapter Interfacing with @gnu{} Automake


@value{PACKAGE} is primarily meant to interface with the parallel test harness of @gnu{} Automake,
@xref{Parallel Test Harness, Parallel Test Harness, Parallel Test Harness, automake, @gnu{}
Automake}.

Let's say we are building a C language library with stem @samp{demo}, which depends on the package
CCExceptions and has source files under the directory @file{src}; we put the following in the
@file{Makefile.am} template:

@example
demo_CURRENT    = 1
demo_REVISION   = 0
demo_AGE        = 0

include_HEADERS         = src/demo.h

lib_LTLIBRARIES         = libdemo.la
libdemo_la_CPPFLAGS     = $(CCEXCEPTIONS_CFLAGS)
libdemo_la_LDFLAGS      = \
   -version-info $(demo_CURRENT):$(demo_REVISION):$(demo_AGE) \
   $(CCEXCEPTIONS_LIBS)
libdemo_la_SOURCES      = \
        src/demo.h              \
        src/demo-internals.h    \
        src/demo-version.c      \
        src/demo-stuff.c
@end example

@noindent
we can declare the test suite programs, with source files under the directory @file{tests}, as
follows:

@example
check_PROGRAMS	= \
  tests/one       \
  tests/two       \
  tests/three

TESTS                   = $(check_PROGRAMS)

demo_tests_cppflags     = \
  -I$(srcdir)/src -I$(srcdir)/tests $(CCTESTS_CFLAGS)
demo_tests_ldadd        = libdemo.la $(CCTESTS_LIBS)

tests_one_CPPFLAGS      = $(demo_tests_cppflags)
tests_one_LDADD         = $(demo_tests_ldadd)

tests_two_CPPFLAGS      = $(demo_tests_cppflags)
tests_two_LDADD         = $(demo_tests_ldadd)

tests_three_CPPFLAGS    = $(cctests_tests_cppflags)
tests_three_LDADD       = $(cctests_tests_ldadd)
tests_three_SOURCES     = \
  tests/three-main.c    \
  tests/three-utils.c   \
  tests/three-header.h
@end example

@noindent
now on the command line we can build everything and run the tests with:

@example
$ make -j3 all && make -j3 check
@end example

@noindent
if we want to run just the tests in the program @file{one}, we can do:

@example
$ make -j3 check cctests_file=one
@end example

@noindent
if we want to run just the tests in the groups named @file{spiffy}, we can do:

@example
$ make -j3 check cctests_group=one
@end example

@noindent
if we want to run just the tests in the test functions whose name include the string @samp{1_3}, we
can do:

@example
$ make -j3 check cctests_name=1_3
@end example

@noindent
obviously we can use multiple environment variables at the same time:

@example
$ make -j3 check cctests_file=two cctests_name=1_3
@end example

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

we can find the package CCExceptions at:

@center @url{http://github.com/marcomaggi/ccexceptions/}


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

